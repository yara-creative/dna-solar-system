<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA Solar System</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #4facfe 75%, #00f2fe 100%);
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
        }
        button[title] {
            --tooltip-delay: 0ms !important;
        }
        button[title]:hover {
            --tooltip-delay: 0ms !important;
        }
        canvas {
            display: block;
            width: 60vw !important;
            height: 100vh !important;
        }
        #back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 12px 24px;
            font-size: 24px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, background 0.3s ease, transform 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            user-select: none;
            touch-action: manipulation;
        }
        #back-btn.active {
            opacity: 1;
            pointer-events: all;
        }
        #back-btn:hover {
            background: white;
            transform: scale(1.1);
        }
        #back-btn:active {
            transform: scale(0.95);
        }
        #text-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 40vw;
            height: 100vh;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: -5px 0 30px rgba(0, 0, 0, 0.1);
            padding: 40px;
            box-sizing: border-box;
            overflow-y: auto;
            z-index: 50;
        }
        #text-content {
            color: #000000;
            font-size: 14px;
            line-height: 1.6;
            letter-spacing: 0.3px;
            margin-bottom: 30px;
            opacity: 1;
            transition: opacity 0.5s ease;
            padding-bottom: 40px;
        }
        #claude-attribution {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            color: #666;
            z-index: 100;
            pointer-events: none;
        }
        #download-btn {
            position: fixed;
            bottom: 20px;
            right: calc(40vw - 160px);
            padding: 10px 20px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, background 0.3s ease, transform 0.2s ease;
            z-index: 100;
        }
        #download-btn.visible {
            opacity: 1;
            pointer-events: all;
        }
        #download-btn:hover {
            background: rgba(102, 126, 234, 1);
            transform: translateY(-2px);
        }
        #download-btn:active {
            transform: translateY(0);
        }
        #text-content.fade-in {
            opacity: 0;
            animation: fadeIn 0.5s ease forwards;
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        #upload-area {
            border: 2px dashed #999;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(0, 0, 0, 0.02);
        }
        #upload-area:hover {
            border-color: #666;
            background: rgba(0, 0, 0, 0.05);
        }
        #upload-area.dragover {
            border-color: #333;
            background: rgba(0, 0, 0, 0.08);
            transform: scale(1.02);
        }
        #upload-text {
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            color: #666;
        }
        #file-input {
            display: none;
        }
        #audio-toggle {
            position: fixed;
            top: 20px;
            right: calc(40vw + 20px);
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }
        #audio-toggle:hover {
            background: white;
            transform: scale(1.1);
        }
        #camera-btn {
            position: fixed;
            bottom: 20px;
            left: calc(60vw - 60px);
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }
        #camera-btn:hover {
            background: white;
            transform: scale(1.1);
        }
        #loading-container {
            display: none;
            margin-top: 20px;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        #loading-container.fade-out {
            opacity: 0;
        }
        #loading-text {
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            color: #666;
            margin-bottom: 10px;
        }
        #loading-bar-bg {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        #loading-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <button id="back-btn">‚Üê</button>
    <button id="audio-toggle" title="Unmute">üîá</button>
    <button id="camera-btn" title="Save a pic">üì∑</button>
    <button id="download-btn">Download PDF</button>
    <audio id="bg-music" loop preload="auto">
        <source src="https://cdn.pixabay.com/audio/2025/06/06/audio_25a5dda27a.mp3" type="audio/mpeg">
    </audio>
    <div id="text-panel">
        <div id="text-content">Welcome to DNA Solar System.<br><br>Please upload your .txt DNA file to generate and explore your system.</div>
        <div id="upload-area">
            <div id="upload-text">Click to upload or drag and drop your .txt file here</div>
        </div>
        <input type="file" id="file-input" accept=".txt">
        <div id="loading-container">
            <div id="loading-text">Generating your unique DNA solar system...</div>
            <div id="loading-bar-bg">
                <div id="loading-bar"></div>
            </div>
        </div>
        <div id="claude-attribution">Built with Claude 4.5</div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================
        // DNA FILTERING LOGIC
        // ============================================
        
        const analysisRsids = new Set([
          'rs1015362', 'rs10246939', 'rs1032507', 'rs1042602', 'rs1042713', 'rs1042714',
          'rs10427255', 'rs1047972', 'rs10484554', 'rs1051266', 'rs1051730', 'rs1061170',
          'rs10757274', 'rs10757278', 'rs10811661', 'rs10830963', 'rs1110400', 'rs11209026',
          'rs1121980', 'rs1128503', 'rs1129038', 'rs11549407', 'rs11571833', 'rs12203592',
          'rs12248560', 'rs12255372', 'rs1229984', 'rs12785878', 'rs12821256', 'rs12896399',
          'rs12913832', 'rs12979860', 'rs1333049', 'rs1393350', 'rs1421085', 'rs1426654',
          'rs1544410', 'rs1570669', 'rs1667394', 'rs16891982', 'rs16969968', 'rs1726866',
          'rs17300539', 'rs174537', 'rs174570', 'rs174575', 'rs17580', 'rs17782313',
          'rs17822931', 'rs1799913', 'rs1799945', 'rs1799971', 'rs1799990', 'rs1800012',
          'rs1800407', 'rs1800497', 'rs1800562', 'rs1800629', 'rs1800795', 'rs1800896',
          'rs1800975', 'rs1801131', 'rs1801133', 'rs1801260', 'rs1801282', 'rs1801394',
          'rs1805007', 'rs1805008', 'rs1815739', 'rs2070744', 'rs2075650', 'rs2108622',
          'rs2234693', 'rs231775', 'rs260690', 'rs2802292', 'rs2814778', 'rs2832407',
          'rs28357377', 'rs28357981', 'rs28358280', 'rs28358584', 'rs28399504', 'rs2853826',
          'rs2854128', 'rs2857285', 'rs28777', 'rs28897756', 'rs28929474', 'rs28931614',
          'rs28940579', 'rs28940580', 'rs3024505', 'rs3088053', 'rs324420', 'rs33950507',
          'rs33971440', 'rs34451549', 'rs35004220', 'rs35705950', 'rs35724775', 'rs3811647',
          'rs3827760', 'rs405509', 'rs4149056', 'rs429358', 'rs4420638', 'rs4422110',
          'rs4680', 'rs4712652', 'rs4988235', 'rs4994', 'rs5030737', 'rs5030868', 'rs5082',
          'rs5219', 'rs53576', 'rs5443', 'rs5882', 'rs601338', 'rs602662', 'rs6265',
          'rs6295', 'rs6313', 'rs6314', 'rs6544713', 'rs671', 'rs6746030', 'rs6983267',
          'rs699', 'rs7041', 'rs713598', 'rs7216389', 'rs72474224', 'rs72552763', 'rs731236',
          'rs73598374', 'rs7412', 'rs75932628', 'rs762551', 'rs7754840', 'rs776746',
          'rs7775228', 'rs7903146', 'rs8192678', 'rs885479', 'rs9264942', 'rs9340799',
          'rs9536314', 'rs9923231', 'rs9939609'
        , "rs1800498", "rs1800955", "rs1799732", "rs6311", "rs4570625", "rs25531", "rs4795541", "rs1360780", "rs460397", "rs228697", "rs17601612", "rs2470893", "rs5186", "rs1799752", "rs4343", "rs12749581", "rs7975232", "rs2187668", "rs7454108", "rs1695", "rs1050450", "rs4880", "rs1256049", "rs2479106", "rs13405728", "rs6259", "rs1799941", "rs1805005", "rs2590498", "rs6025", "rs1799963", "rs965513", "rs2238151"]);

        function filterDNAFile(fileContent) {
          const lines = fileContent.split('\n');
          const header = lines[0];
          const filteredLines = [header];
          
          let originalCount = 0;
          let filteredCount = 0;
          
          for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line || line.startsWith('#')) continue;
            
            originalCount++;
            const rsid = line.split(/[\t\s]+/)[0];
            
            if (analysisRsids.has(rsid)) {
              filteredLines.push(line);
              filteredCount++;
            }
          }
          
          const filteredContent = filteredLines.join('\n');
          const reduction = ((1 - filteredCount / originalCount) * 100).toFixed(1);
          
          return {
            filteredContent,
            originalCount,
            filteredCount,
            reduction
          };
        }

        async function analyzeDNAWithClaude(filteredContent) {
            const apiKey = 'YOUR_CLAUDE_API_KEY'; // Replace with your API key
            
            // Simulate loading progress
            const loadingBar = document.getElementById('loading-bar');
            loadingBar.style.width = '30%';
            
            const prompt = `[DNA ANALYSIS PROMPT - TO BE CUSTOMIZED]
            
Analyze the following filtered DNA data and provide insights across these 7 categories:
1. Origins - DNA ancestry
2. Mind - Cognitive patterns, focus, mental health predispositions
3. Body - Physical traits, strength, endurance, recovery
4. Nutrition - Nutrient processing, dietary sensitivities
5. Sleep - Sleep patterns, energy, circadian rhythms
6. Senses - Physical appearance, sensory traits
7. Resilience - Repair mechanisms, longevity factors

DNA Data:
${filteredContent}

Provide detailed, personalized insights for each category.`;

            loadingBar.style.width = '60%';
            
            try {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 4096,
                        messages: [{
                            role: 'user',
                            content: prompt
                        }]
                    })
                });
                
                loadingBar.style.width = '90%';
                
                const data = await response.json();
                loadingBar.style.width = '100%';
                
                return data.content[0].text;
            } catch (error) {
                console.error('Claude API error:', error);
                loadingBar.style.width = '100%';
                return 'Analysis complete. Click on objects to explore your DNA insights.';
            }
        }

        // ============================================
        // ORIGINAL CODE CONTINUES
        // ============================================
        
        let scene, camera, renderer;
        let dnaHelix;
        let circleObjects = [];
        let time = 0;
        let raycaster, mouse;
        let isZoomedIn = false;
        let zoomedObject = null;
        let cameraTarget = { x: 0, y: 0, z: 8 };
        let cameraLookAt = { x: 0, y: 0, z: 0 };
        let isTransitioning = false;
        let transitionProgress = 0;
        let dnaParticles = [];

        class PerlinNoise {
            constructor() {
                this.perm = [];
                for(let i = 0; i < 256; i++) this.perm[i] = i;
                for(let i = 255; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];
                }
                this.perm = this.perm.concat(this.perm);
            }
            
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
            
            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const a = this.perm[X] + Y;
                const b = this.perm[X + 1] + Y;
                return this.lerp(v,
                    this.lerp(u, this.grad(this.perm[a], x, y),
                                 this.grad(this.perm[b], x - 1, y)),
                    this.lerp(u, this.grad(this.perm[a + 1], x, y - 1),
                                 this.grad(this.perm[b + 1], x - 1, y - 1))
                );
            }
        }

        const perlin = new PerlinNoise();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f0);
            scene.fog = new THREE.Fog(0x8e44ad, 15, 30);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            camera = new THREE.PerspectiveCamera(75, (window.innerWidth * 0.6) / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 8);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth * 0.6, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            createDNAHelix();

            for (let i = 0; i < 80; i++) {
                const vibrantColors = [
                    0xff6b9d, 0xc44569, 0x8e44ad, 0x3498db, 
                    0x1abc9c, 0xf39c12, 0xe74c3c, 0x9b59b6,
                    0xff6348, 0xfeca57, 0x48dbfb, 0xff9ff3,
                    0x54a0ff, 0xee5a6f, 0x00d2d3, 0x5f27cd
                ];
                const randomColor = vibrantColors[Math.floor(Math.random() * vibrantColors.length)];
                const size = Math.random() * 0.15 + 0.05;
                const x = (Math.random() - 0.5) * 15;
                const y = (Math.random() - 0.5) * 10;
                const z = (Math.random() - 0.5) * 15;
                createFloatingParticle(x, y, z, randomColor, size);
            }

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 8, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const pointLight1 = new THREE.PointLight(0xff6b9d, 1.2, 20);
            pointLight1.position.set(-5, 3, 3);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x3498db, 1.0, 20);
            pointLight2.position.set(5, 3, -3);
            scene.add(pointLight2);

            const pointLight3 = new THREE.PointLight(0xf39c12, 0.8, 18);
            pointLight3.position.set(0, 5, 5);
            scene.add(pointLight3);

            const pointLight4 = new THREE.PointLight(0x1abc9c, 0.9, 18);
            pointLight4.position.set(0, -2, -5);
            scene.add(pointLight4);

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('click', onMouseClick, false);
            
            const backBtn = document.getElementById('back-btn');
            backBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                zoomOut();
            });
            backBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                e.stopPropagation();
                zoomOut();
            });
            
            setupFileUpload();
            setupAudio();
            setupDownloadButton();
            setupCameraButton();
        }

        function setupDownloadButton() {
            const downloadBtn = document.getElementById('download-btn');
            downloadBtn.addEventListener('click', downloadPDF);
        }

        function downloadPDF() {
            // Placeholder for PDF generation
            console.log('PDF download - to be implemented');
        }

        function setupCameraButton() {
            const cameraBtn = document.getElementById('camera-btn');
            cameraBtn.addEventListener('click', captureImage);
        }

        function captureImage() {
            const strMime = "image/jpeg";
            const imgData = renderer.domElement.toDataURL(strMime);
            
            const link = document.createElement('a');
            link.download = 'dna-solar-system.jpg';
            link.href = imgData;
            link.click();
        }

        function setupAudio() {
            const audio = document.getElementById('bg-music');
            const toggle = document.getElementById('audio-toggle');
            let isPlaying = false;
            
            audio.volume = 0.3;
            
            // Autoplay on first user interaction
            const startAudio = () => {
                if (!isPlaying) {
                    audio.play().catch(err => console.log('Audio play failed:', err));
                    toggle.textContent = 'üîä';
                    toggle.title = 'Mute';
                    isPlaying = true;
                }
                document.removeEventListener('click', startAudio);
            };
            document.addEventListener('click', startAudio, { once: true });
            
            toggle.addEventListener('click', () => {
                if (isPlaying) {
                    audio.pause();
                    toggle.textContent = 'üîá';
                    toggle.title = 'Unmute';
                    isPlaying = false;
                } else {
                    audio.play().catch(err => console.log('Audio play failed:', err));
                    toggle.textContent = 'üîä';
                    toggle.title = 'Mute';
                    isPlaying = true;
                }
            });
            

        }

        function setupFileUpload() {
            const uploadArea = document.getElementById('upload-area');
            const fileInput = document.getElementById('file-input');
            
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    handleFile(file);
                }
            });
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });
            
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.name.endsWith('.txt')) {
                    handleFile(file);
                } else {
                    alert('Please upload a .txt file');
                }
            });
        }
        
        async function handleFile(file) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                const originalContent = e.target.result;
                
                console.log('Original file loaded:', file.name);
                console.log('Processing DNA data...');
                
                // Hide upload area and welcome text, show loading
                document.getElementById('upload-area').style.display = 'none';
                document.getElementById('text-content').style.display = 'none';
                document.getElementById('loading-container').style.display = 'block';
                
                // Filter the DNA file
                const result = filterDNAFile(originalContent);
                
                console.log('=== DNA Processing Complete ===');
                console.log(`Original SNPs: ${result.originalCount.toLocaleString()}`);
                console.log(`Filtered SNPs: ${result.filteredCount}`);
                console.log(`Size reduction: ${result.reduction}%`);
                console.log('Analyzing with Claude...');
                
                // Initial loading bar progress
                document.getElementById('loading-bar').style.width = '10%';
                
                // Store the filtered content globally
                window.filteredDNAContent = result.filteredContent;
                window.filteredFileName = file.name.replace(/\.txt$/, '_filtered.txt');
                
                // Analyze with Claude
                const analysis = await analyzeDNAWithClaude(result.filteredContent);
                window.dnaAnalysis = analysis;
                
                console.log('Claude analysis complete');
                
                // Small delay to show 100% completion
                setTimeout(() => {
                    startTransition();
                }, 500);
            };
            reader.readAsText(file);
        }

        function startTransition() {
            isTransitioning = true;
            transitionProgress = 0;
            
            convertDNAToParticles();
        }

        function convertDNAToParticles() {
            dnaHelix.traverse(child => {
                if (child.isMesh) {
                    const particle = {
                        mesh: child,
                        startPos: child.position.clone(),
                        startScale: child.scale.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1
                        )
                    };
                    dnaParticles.push(particle);
                }
            });
        }

        function showDownloadButton() {
            document.getElementById('download-btn').classList.add('visible');
        }

        function updateTransition() {
            if (!isTransitioning) return;
            
            transitionProgress += 0.003;
            
            // When transition completes, fade out loading and fade in text
            if (transitionProgress >= 1 && document.getElementById('loading-container').style.display !== 'none') {
                const loadingContainer = document.getElementById('loading-container');
                const textContent = document.getElementById('text-content');
                
                // Fade out loading
                loadingContainer.classList.add('fade-out');
                
                setTimeout(() => {
                    loadingContainer.style.display = 'none';
                showDownloadButton();
                    loadingContainer.classList.remove('fade-out');
                    
                    // Fade in text
                    textContent.style.display = 'block';
                    textContent.classList.add('fade-in');
                    textContent.innerHTML = 'Your DNA Solar System<br><br>Explore the unique set of planets generated from your DNA sequence - one of over 10 million possibilities!<br><br>Click on any planet to learn insights about your DNA.';
                    
                    setTimeout(() => {
                        textContent.classList.remove('fade-in');
                    }, 500);
                }, 500);
            }
            
            const phase1Duration = 0.45;
            const phase2Duration = 0.55;
            
            if (transitionProgress < phase1Duration) {
                const t = transitionProgress / phase1Duration;
                const easeT = t * t * (3 - 2 * t);
                
                cameraTarget.y = 0 + easeT * 5;
                cameraTarget.z = 8 + easeT * 7;
                
                dnaHelix.rotation.y += 0.02;
                dnaHelix.scale.setScalar(1 + easeT * 0.3);
                
                dnaParticles.forEach(particle => {
                    particle.mesh.position.add(particle.velocity);
                    particle.velocity.multiplyScalar(1.03);
                    
                    const fadeT = Math.min(1, t * 2);
                    if (particle.mesh.material.opacity !== undefined) {
                        particle.mesh.material.opacity = 1 - fadeT;
                    }
                });
                
            } else if (transitionProgress < phase1Duration + phase2Duration) {
                const t = (transitionProgress - phase1Duration) / phase2Duration;
                const easeT = t * t * (3 - 2 * t);
                
                cameraTarget.y = 5 + easeT * 5;
                cameraTarget.z = 15 - easeT * 15;
                
                if (circleObjects.length === 0) {
                    createSolarSystemObjects();
                }
                
                circleObjects.forEach((obj, index) => {
                    const delayPerObject = 0.08;
                    const objectStartTime = index * delayPerObject;
                    const objectT = Math.max(0, (t - objectStartTime) / (1 - objectStartTime));
                    const targetScale = Math.min(1, objectT * 1.5);
                    
                    obj.currentScale += (targetScale - obj.currentScale) * 0.08;
                    obj.mesh.scale.setScalar(obj.currentScale);
                });
                
            } else {
                isTransitioning = false;
                cameraTarget.x = 0;
                cameraTarget.y = 10;
                cameraTarget.z = 0;
                
                scene.remove(dnaHelix);
                dnaParticles = [];
                
                document.getElementById('text-content').innerHTML = 'Your DNA Solar System<br><br>Explore the objects generated from your DNA sequence. Click on any object to examine it closer.';
            }
        }

        function createDNAHelix() {
            dnaHelix = new THREE.Group();

            const height = 6;
            const radius = 1.2;
            const segments = 35;
            const turns = 2;

            for (let i = 0; i < segments; i++) {
                const t = i / segments;
                const y = (t - 0.5) * height;
                const angle = t * Math.PI * 2 * turns;

                const x1 = Math.cos(angle) * radius;
                const z1 = Math.sin(angle) * radius;
                const x2 = Math.cos(angle + Math.PI) * radius;
                const z2 = Math.sin(angle + Math.PI) * radius;

                const sphereGeo = new THREE.SphereGeometry(0.12, 16, 16);
                
                const sphere1Mat = new THREE.MeshPhysicalMaterial({
                    color: 0x2c2c2c,
                    roughness: 0.1,
                    metalness: 0.9,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1,
                    reflectivity: 1.0,
                    envMapIntensity: 1.5,
                    transparent: true,
                    opacity: 1
                });
                const sphere1 = new THREE.Mesh(sphereGeo, sphere1Mat);
                sphere1.position.set(x1, y, z1);
                dnaHelix.add(sphere1);

                const sphere2Mat = new THREE.MeshPhysicalMaterial({
                    color: 0x2c2c2c,
                    roughness: 0.1,
                    metalness: 0.9,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1,
                    reflectivity: 1.0,
                    envMapIntensity: 1.5,
                    transparent: true,
                    opacity: 1
                });
                const sphere2 = new THREE.Mesh(sphereGeo, sphere2Mat);
                sphere2.position.set(x2, y, z2);
                dnaHelix.add(sphere2);

                if (i % 2 === 0) {
                    const rungStart = new THREE.Vector3(x1, y, z1);
                    const rungEnd = new THREE.Vector3(x2, y, z2);
                    const rungCenter = new THREE.Vector3().addVectors(rungStart, rungEnd).multiplyScalar(0.5);
                    const rungLength = rungStart.distanceTo(rungEnd);
                    
                    const rungGeo = new THREE.CylinderGeometry(0.025, 0.025, rungLength, 8);
                    const rungMat = new THREE.MeshPhysicalMaterial({
                        color: 0xffffff,
                        roughness: 0.05,
                        metalness: 1.0,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.05,
                        reflectivity: 1.0,
                        envMapIntensity: 2.0,
                        transparent: true,
                        opacity: 1
                    });
                    const rung = new THREE.Mesh(rungGeo, rungMat);
                    rung.position.copy(rungCenter);
                    
                    const direction = new THREE.Vector3().subVectors(rungEnd, rungStart).normalize();
                    rung.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                    
                    dnaHelix.add(rung);
                }

                if (i < segments - 1) {
                    const nextT = (i + 1) / segments;
                    const nextY = (nextT - 0.5) * height;
                    const nextAngle = nextT * Math.PI * 2 * turns;
                    const nextX1 = Math.cos(nextAngle) * radius;
                    const nextZ1 = Math.sin(nextAngle) * radius;

                    const backboneGeo1 = new THREE.CylinderGeometry(0.04, 0.04, 
                        Math.sqrt((nextX1-x1)**2 + (nextY-y)**2 + (nextZ1-z1)**2), 8);
                    const backboneMat1 = new THREE.MeshPhysicalMaterial({
                        color: 0x3a3a3a,
                        roughness: 0.2,
                        metalness: 0.8,
                        clearcoat: 0.5,
                        reflectivity: 0.8,
                        transparent: true,
                        opacity: 1
                    });
                    const backbone1 = new THREE.Mesh(backboneGeo1, backboneMat1);
                    backbone1.position.set((x1 + nextX1) / 2, (y + nextY) / 2, (z1 + nextZ1) / 2);
                    const dir1 = new THREE.Vector3(nextX1 - x1, nextY - y, nextZ1 - z1).normalize();
                    backbone1.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir1);
                    dnaHelix.add(backbone1);

                    const nextX2 = Math.cos(nextAngle + Math.PI) * radius;
                    const nextZ2 = Math.sin(nextAngle + Math.PI) * radius;
                    const backboneGeo2 = new THREE.CylinderGeometry(0.04, 0.04, 
                        Math.sqrt((nextX2-x2)**2 + (nextY-y)**2 + (nextZ2-z2)**2), 8);
                    const backboneMat2 = new THREE.MeshPhysicalMaterial({
                        color: 0x3a3a3a,
                        roughness: 0.2,
                        metalness: 0.8,
                        clearcoat: 0.5,
                        reflectivity: 0.8,
                        transparent: true,
                        opacity: 1
                    });
                    const backbone2 = new THREE.Mesh(backboneGeo2, backboneMat2);
                    backbone2.position.set((x2 + nextX2) / 2, (y + nextY) / 2, (z2 + nextZ2) / 2);
                    const dir2 = new THREE.Vector3(nextX2 - x2, nextY - y, nextZ2 - z2).normalize();
                    backbone2.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir2);
                    dnaHelix.add(backbone2);
                }
            }

            scene.add(dnaHelix);
        }

        function createSolarSystemObjects() {
            const colors = [
                0xFF6B9D, 0x9B59B6, 0x3498DB, 0x1ABC9C, 
                0xF39C12, 0xE74C3C, 0xC44569
            ];

            const numObjects = 7;
            const radius = 4;
            
            const shapeFunctions = [
                createTorus, createKnot, createSpiral, createCrystal,
                createRibbon, createStarBurst, createTwistedBox
            ];
            
            for (let i = 0; i < numObjects; i++) {
                const angle = (i / numObjects) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                shapeFunctions[i](x, 0, z, colors[i], angle);
            }
        }

        function createTorus(x, y, z, color, angle) {
            const group = new THREE.Group();
            
            for (let i = 0; i < 3; i++) {
                const glowSize = 1.2 + i * 0.3;
                const glowOpacity = 0.2 - i * 0.06;
                const glowGeo = new THREE.CircleGeometry(glowSize, 32);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: glowOpacity,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.rotation.x = -Math.PI / 2;
                group.add(glow);
            }
            
            const geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 32);
            
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            const imageData = ctx.createImageData(512, 512);
            for (let y = 0; y < 512; y++) {
                for (let x = 0; x < 512; x++) {
                    let value = 0;
                    let scale = 0.01;
                    let amplitude = 1;
                    for (let octave = 0; octave < 4; octave++) {
                        value += perlin.noise(x * scale, y * scale) * amplitude;
                        scale *= 2;
                        amplitude *= 0.5;
                    }
                    
                    const marble = Math.abs(Math.sin((x * 0.05 + value * 5) * Math.PI));
                    const brightness = 200 + marble * 55;
                    const idx = (y * 512 + x) * 4;
                    imageData.data[idx] = brightness;
                    imageData.data[idx + 1] = brightness;
                    imageData.data[idx + 2] = brightness;
                    imageData.data[idx + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            
            const material = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.2,
                metalness: 0.05,
                color: new THREE.Color(color).lerp(new THREE.Color(0xffffff), 0.7)
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = Math.PI / 4;
            mesh.castShadow = true;
            group.add(mesh);
            
            group.position.set(x, y, z);
            group.scale.set(0, 0, 0);
            scene.add(group);
            
            circleObjects.push({ 
                mesh: group, angle,
                originalX: x, originalZ: z,
                rotationSpeed: 0.4,
                targetScale: 1, currentScale: 0
            });
        }

        function createKnot(x, y, z, color, angle) {
            const group = new THREE.Group();
            
            for (let i = 0; i < 4; i++) {
                const glowSize = 1.2 + i * 0.25;
                const glowOpacity = 0.3 - i * 0.07;
                const glowGeo = new THREE.CircleGeometry(glowSize, 32);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: glowOpacity,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.rotation.x = -Math.PI / 2;
                group.add(glow);
            }
            
            const geometry = new THREE.TorusKnotGeometry(0.4, 0.15, 64, 8, 2, 3);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.3,
                metalness: 0.6
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            group.add(mesh);
            
            group.position.set(x, y, z);
            group.scale.set(0, 0, 0);
            scene.add(group);
            
            circleObjects.push({ 
                mesh: group, angle,
                originalX: x, originalZ: z,
                rotationSpeed: 0.3,
                targetScale: 1, currentScale: 0
            });
        }

        function createSpiral(x, y, z, color, angle) {
            const group = new THREE.Group();
            
            for (let i = 0; i < 4; i++) {
                const glowSize = 1.3 + i * 0.3;
                const glowOpacity = 0.35 - i * 0.08;
                const glowGeo = new THREE.CircleGeometry(glowSize, 32);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: glowOpacity,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.rotation.x = -Math.PI / 2;
                group.add(glow);
            }
            
            const sphereGeo = new THREE.SphereGeometry(0.08, 12, 12);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.5,
                metalness: 0.3
            });
            
            for (let i = 0; i < 50; i++) {
                const t = i / 50;
                const spiralAngle = t * Math.PI * 6;
                const spiralRadius = t * 0.6;
                const sphere = new THREE.Mesh(sphereGeo, material);
                sphere.position.set(
                    Math.cos(spiralAngle) * spiralRadius,
                    (t - 0.5) * 1.5,
                    Math.sin(spiralAngle) * spiralRadius
                );
                sphere.castShadow = true;
                group.add(sphere);
            }
            
            group.position.set(x, y, z);
            group.scale.set(0, 0, 0);
            scene.add(group);
            
            circleObjects.push({ 
                mesh: group, angle,
                originalX: x, originalZ: z,
                rotationSpeed: 0.25,
                targetScale: 1, currentScale: 0
            });
        }

        function createCrystal(x, y, z, color, angle) {
            const group = new THREE.Group();
            
            for (let i = 0; i < 4; i++) {
                const glowSize = 1.1 + i * 0.28;
                const glowOpacity = 0.4 - i * 0.09;
                const glowGeo = new THREE.CircleGeometry(glowSize, 32);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: glowOpacity,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.rotation.x = -Math.PI / 2;
                group.add(glow);
            }
            
            const geometry = new THREE.OctahedronGeometry(0.7, 0);
            const positions = geometry.attributes.position;
            
            for (let i = 0; i < positions.count; i++) {
                const py = positions.getY(i);
                positions.setY(i, py * 1.3);
            }
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.2,
                metalness: 0.8,
                flatShading: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            group.add(mesh);
            
            group.position.set(x, y, z);
            group.scale.set(0, 0, 0);
            scene.add(group);
            
            circleObjects.push({ 
                mesh: group, angle,
                originalX: x, originalZ: z,
                rotationSpeed: 0.35,
                targetScale: 1, currentScale: 0
            });
        }

        function createRibbon(x, y, z, color, angle) {
            const group = new THREE.Group();
            
            for (let i = 0; i < 4; i++) {
                const glowSize = 1.4 + i * 0.3;
                const glowOpacity = 0.3 - i * 0.07;
                const glowGeo = new THREE.CircleGeometry(glowSize, 32);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: glowOpacity,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.rotation.x = -Math.PI / 2;
                group.add(glow);
            }
            
            const segments = 40;
            
            for (let i = 0; i < segments; i++) {
                const t = i / segments;
                const ribbonAngle = t * Math.PI * 2;
                const twist = t * Math.PI;
                
                const boxGeo = new THREE.BoxGeometry(0.15, 0.05, 0.4);
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.4,
                    metalness: 0.4
                });
                const box = new THREE.Mesh(boxGeo, material);
                
                const radius = 0.6;
                box.position.set(
                    Math.cos(ribbonAngle) * radius,
                    Math.sin(twist) * 0.2,
                    Math.sin(ribbonAngle) * radius
                );
                box.rotation.y = ribbonAngle;
                box.rotation.x = twist;
                box.castShadow = true;
                group.add(box);
            }
            
            group.position.set(x, y, z);
            group.scale.set(0, 0, 0);
            scene.add(group);
            
            circleObjects.push({ 
                mesh: group, angle,
                originalX: x, originalZ: z,
                rotationSpeed: 0.2,
                targetScale: 1, currentScale: 0
            });
        }

        function createStarBurst(x, y, z, color, angle) {
            const group = new THREE.Group();
            
            for (let i = 0; i < 5; i++) {
                const glowSize = 1.5 + i * 0.35;
                const glowOpacity = 0.4 - i * 0.08;
                const glowGeo = new THREE.CircleGeometry(glowSize, 32);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: glowOpacity,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.rotation.x = -Math.PI / 2;
                group.add(glow);
            }
            
            const numSpikes = 12;
            
            for (let i = 0; i < numSpikes; i++) {
                const spikeAngle = (i / numSpikes) * Math.PI * 2;
                const cylinderGeo = new THREE.CylinderGeometry(0.05, 0.02, 0.8, 8);
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.3,
                    metalness: 0.6
                });
                const spike = new THREE.Mesh(cylinderGeo, material);
                
                spike.position.set(
                    Math.cos(spikeAngle) * 0.2,
                    0,
                    Math.sin(spikeAngle) * 0.2
                );
                spike.rotation.z = Math.PI / 2;
                spike.rotation.y = spikeAngle;
                spike.castShadow = true;
                group.add(spike);
            }
            
            const centerGeo = new THREE.SphereGeometry(0.2, 16, 16);
            const centerMat = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.2,
                metalness: 0.8
            });
            const center = new THREE.Mesh(centerGeo, centerMat);
            center.castShadow = true;
            group.add(center);
            
            group.position.set(x, y, z);
            group.scale.set(0, 0, 0);
            scene.add(group);
            
            circleObjects.push({ 
                mesh: group, angle,
                originalX: x, originalZ: z,
                rotationSpeed: 0.3,
                targetScale: 1, currentScale: 0
            });
        }

        function createTwistedBox(x, y, z, color, angle) {
            const group = new THREE.Group();
            
            for (let i = 0; i < 4; i++) {
                const glowSize = 1.3 + i * 0.3;
                const glowOpacity = 0.35 - i * 0.08;
                const glowGeo = new THREE.CircleGeometry(glowSize, 32);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: glowOpacity,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.rotation.x = -Math.PI / 2;
                group.add(glow);
            }
            
            const layers = 8;
            
            for (let i = 0; i < layers; i++) {
                const t = i / layers;
                const boxGeo = new THREE.BoxGeometry(0.6, 0.15, 0.6);
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.5,
                    metalness: 0.3
                });
                const box = new THREE.Mesh(boxGeo, material);
                
                box.position.y = (t - 0.5) * 1.2;
                box.rotation.y = t * Math.PI / 2;
                box.castShadow = true;
                group.add(box);
            }
            
            group.position.set(x, y, z);
            group.scale.set(0, 0, 0);
            scene.add(group);
            
            circleObjects.push({ 
                mesh: group, angle,
                originalX: x, originalZ: z,
                rotationSpeed: 0.25,
                targetScale: 1, currentScale: 0
            });
        }

        function createFloatingParticle(x, y, z, color, size) {
            const geometry = new THREE.SphereGeometry(size, 12, 12);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.3,
                metalness: 0.5,
                emissive: color,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.7
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            scene.add(mesh);
            
            if (!window.floatingParticles) window.floatingParticles = [];
            window.floatingParticles.push({
                mesh: mesh,
                originalY: y,
                speed: Math.random() * 0.3 + 0.1,
                offset: Math.random() * Math.PI * 2
            });
        }

        function onWindowResize() {
            camera.aspect = (window.innerWidth * 0.6) / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth * 0.6, window.innerHeight);
        }

        function onMouseMove(event) {
            const canvasWidth = window.innerWidth * 0.6;
            if (event.clientX > canvasWidth) return;
            
            mouse.x = (event.clientX / canvasWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onMouseClick(event) {
            const canvasWidth = window.innerWidth * 0.6;
            if (event.clientX > canvasWidth) return;
            if (isZoomedIn) return;
            if (circleObjects.length === 0) return;
            
            mouse.x = (event.clientX / canvasWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const allMeshes = [];
            circleObjects.forEach(obj => {
                obj.mesh.traverse(child => {
                    if (child.isMesh) {
                        allMeshes.push({ mesh: child, parent: obj });
                    }
                });
            });
            
            const intersects = raycaster.intersectObjects(allMeshes.map(m => m.mesh));

            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                const objData = allMeshes.find(m => m.mesh === clickedMesh);
                if (objData && objData.parent) {
                    zoomToObject(objData.parent);
                }
            }
        }

        function zoomToObject(objData) {
            isZoomedIn = true;
            zoomedObject = objData;
            
            const objPos = objData.mesh.position;
            
            cameraTarget.x = objPos.x + 3;
            cameraTarget.y = objPos.y;
            cameraTarget.z = objPos.z;
            
            cameraLookAt.x = objPos.x;
            cameraLookAt.y = objPos.y;
            cameraLookAt.z = objPos.z;
            
            document.getElementById('back-btn').classList.add('active');
            
            updateTextPanel(objData);
        }
        
        function updateTextPanel(objData) {
            const categories = [
                { name: 'Origins', subtitle: 'Your DNA ancestry' },
                { name: 'Mind', subtitle: 'How you think, feel, and focus' },
                { name: 'Body', subtitle: 'Your strength, endurance, and recovery' },
                { name: 'Nutrition', subtitle: 'How your body processes food & nutrients' },
                { name: 'Sleep', subtitle: 'Your sleep, energy, and daily cycles' },
                { name: 'Senses', subtitle: 'Visible traits & sensory quirks' },
                { name: 'Resilience', subtitle: 'Ability to repair & longevity' }
            ];
            
            const index = circleObjects.indexOf(objData);
            const category = categories[index];
            
            document.getElementById('text-content').innerHTML = 
                `<span style="text-decoration: underline;">${category.name}</span><br>${category.subtitle}`;
        }

        function zoomOut() {
            isZoomedIn = false;
            zoomedObject = null;
            
            cameraTarget.x = 0;
            cameraTarget.y = 10;
            cameraTarget.z = 0;
            
            cameraLookAt.x = 0;
            cameraLookAt.y = 0;
            cameraLookAt.z = 0;
            
            document.getElementById('back-btn').classList.remove('active');
            
            document.getElementById('text-content').innerHTML = 'Your DNA Solar System<br><br>Explore the unique set of planets generated from your DNA sequence - one of over 10 million possibilities!<br><br>Click on any planet to learn insights about your DNA.';
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            updateTransition();

            camera.position.x += (cameraTarget.x - camera.position.x) * 0.05;
            camera.position.y += (cameraTarget.y - camera.position.y) * 0.05;
            camera.position.z += (cameraTarget.z - camera.position.z) * 0.05;
            
            camera.lookAt(cameraLookAt.x, cameraLookAt.y, cameraLookAt.z);

            if (dnaHelix && !isTransitioning) {
                dnaHelix.rotation.y += 0.005;
            }

            if (window.floatingParticles) {
                window.floatingParticles.forEach(particle => {
                    particle.mesh.position.y = particle.originalY + 
                        Math.sin(time * particle.speed + particle.offset) * 0.5;
                    particle.mesh.rotation.x += 0.01;
                    particle.mesh.rotation.y += 0.01;
                });
            }

            if (!isZoomedIn && !isTransitioning && circleObjects.length > 0) {
                raycaster.setFromCamera(mouse, camera);
                
                const allMeshes = [];
                circleObjects.forEach(obj => {
                    obj.mesh.traverse(child => {
                        if (child.isMesh) {
                            allMeshes.push({ mesh: child, parent: obj });
                        }
                    });
                });
                
                const intersects = raycaster.intersectObjects(allMeshes.map(m => m.mesh));

                circleObjects.forEach(obj => {
                    obj.targetScale = 1;
                });

                if (intersects.length > 0) {
                    const hoveredMesh = intersects[0].object;
                    const objData = allMeshes.find(m => m.mesh === hoveredMesh);
                    if (objData && objData.parent) {
                        objData.parent.targetScale = 1.3;
                        document.body.style.cursor = 'pointer';
                    }
                } else {
                    document.body.style.cursor = 'default';
                }
            }

            if (circleObjects.length > 0) {
                circleObjects.forEach(({ mesh, rotationSpeed }, index) => {
                    mesh.rotation.x += 0.005 * rotationSpeed;
                    mesh.rotation.y += 0.008 * rotationSpeed;
                    mesh.rotation.z += 0.003 * rotationSpeed;

                    const obj = circleObjects[index];
                    obj.currentScale += (obj.targetScale - obj.currentScale) * 0.1;
                    mesh.scale.set(obj.currentScale, obj.currentScale, obj.currentScale);
                });
            }

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>